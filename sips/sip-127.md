---
sip: 127
title: Siloed debt pools
status: WIP
author: Liam Zebedee (@liamzebedee)
discussions-to: <Create a new thread on https://research.synthetix.io and drop the link here> 
created: <date created on, in ISO 8601 (yyyy-mm-dd) format>
requires (*optional): <SIP number(s)>
---

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Simply describe the outcome the proposed changes intends to achieve. This should be non-technical and accessible to a casual community member.-->
Siloed debt pools will allow more synthetic assets of varying risk profiles to be added to the network. This adds value for traders, and allows stakers to better select to which assets they are exposed.

## Abstract
<!--A short (~200 word) description of the proposed change, the abstract should clearly describe the proposed change. This is what *will* be done if the SIP is implemented, not *why* it should be done or *how* it will be done. If the SIP proposes deploying a new contract, write, "we propose to deploy a new contract that will do x".-->
We propose to introduce a new contract, the `DebtPool`, which encapsulates much of the logic of the existing global debt pool, including the debt cache, fee pool, etc. Each debt pool supports a basket of synthetics, wherein it can issue loans for SNX. The implicit global debt pool is migrated to use the DebtPool contract.

## Motivation
<!--This is the problem statement. This is the *why* of the SIP. It should clearly explain *why* the current state of the protocol is inadequate.  It is critical that you explain *why* the change is needed, if the SIP proposes changing how something is calculated, you must address *why* the current calculation is innaccurate or wrong. This is not the place to describe how the SIP will address the issue!-->

* The Synthetix network currently supports on order of 64+ different assets (including inverse synths). 
* Competing protocols are beginning to take the lead on supporting more assets quicker. Mirror.finance already supports XYZ more equity synths.
* The addition of new synths to the Synthetix network is fundamental to providing more value to users as they can enter/exit markets in any asset they like.
* However, there are two constraints to solving this problem:
* 1) adding new assets increases exposure for the global debt pool. With every new asset added, stakers must find a way to hedge their position for/against price movements in that asset.
* 2) the ethereum gas limit for transactions sets an upper bound for the number of assets that can be included in a calculation of total debt. According to some research done by Ale, this limit is 30 unique assets (excluding inverse synths) in the current design.

## Specification
<!--The specification should describe the syntax and semantics of any new feature, there are five sections
1. Overview
2. Rationale
3. Technical Specification
4. Test Cases
5. Configurable Values
-->

### Overview
<!--This is a high level overview of *how* the SIP will solve the problem. The overview should clearly describe how the new feature will be implemented.-->
* A new contract, `DebtPool`, will be deployed. Debt pools allow users to stake SNX and receive tokenised debt in the form of a token called eSNX. Users can issue and burn a variety of assets supported by that debt pool - these are configurable via SCCP. 
* Initially, a synthetic asset may only be backed by one debt pool in the system. The issuer contract will be modified to permission stakers to only mint assets as mapped to their debt pool.
* A debt pool encapsulates the logic of a debt register, currently located in `SynthetixState`. However, unlike the single implicit debt pool as exists today, these debt pools will be siloed - undercollateralisation in one pool will not risk a user's staked SNX in another. 
* Fees that are generated from exchange of assets will continue being issued to the fee pool address. However, the mechanism of claiming those fees will be modified - users may claim fees using their eSNX, proportionate to total eSNX supply (staked SNX). 

### Rationale
<!--This is where you explain the reasoning behind how you propose to solve the problem. Why did you propose to implement the change in this way, what were the considerations and trade-offs. The rationale fleshes out what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->
* eSNX:
  * eSNX staking would bring SNX up-to-date with modern token behaviour. Right now, staking is implemented as a lock on a portion of the user balance, instead of an escrow system, which is idiosyncratic.
* Tokenised debt:
  * Tokenisation simplifies UX for some common user flows, negating the need for flash loans to migrate positions between accounts.
  * Tokenisation is well-understood as a base for innovation in the DeFi ecosystem. 
  * Debt in more stable debt pools can be used as collateral in more riskier pools, enabling greater capital efficiency. For example, say there is a stablecoins pool and a forex pool. Stakers who provide liquidity to the stablecoin pool can take their trading profits and provide it in the forex pool. 

### Considerations

* Should we replace the implicit global debt pool with an explicit `DebtPool` instance?
* Should we introduce tokenised debt as part of this SIP?

### Technical Specification
<!--The technical specification should outline the public API of the changes proposed. That is, changes to any of the interfaces Synthetix currently exposes or the creations of new ones.-->

```sol
// eSNX
contract EscrowedSNX is ERC20 {
    ISynthetix snx;

    mapping(address => uint) staked;
    mapping(address => uint) balances;

    constructor() 
        ERC20("eSNX", "Staked SNX")
    {
    }

    function stake(uint amount) {
        snx.transferFrom(msg.sender, address(this), amount);
        staked[msg.sender] = staked[msg.sender].add(amount);
        balances[msg.sender] = balances[msg.sender].add(amount);
    }

    function unstake(uint amount) {
        // verify _canTransfer invariant.
        staked[msg.sender] = staked[msg.sender].sub(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        snx.transfer(msg.sender, amount);
    }

    function balanceOf(address account) {
        return balances[account];
    }
}

contract DebtPool is EscrowedSNX {
    using SafeMath for uint;
    using SafeDecimalMath for uint;

    // A struct for handing values associated with an individual user's debt position
    struct IssuanceData {
        // Percentage of the total debt owned at the time
        // of issuance. This number is modified by the global debt
        // delta array. You can figure out a user's exit price and
        // collateralisation ratio using a combination of their initial
        // debt and the slice of global debt delta which applies to them.
        uint initialDebtOwnership;
        // This lets us know when (in relative terms) the user entered
        // the debt pool so we can calculate their exit price and
        // collateralistion ratio
        uint debtEntryIndex;
    }

    // Issued synth balances for individual fee entitlements and exit price calculations
    mapping(address => IssuanceData) public issuanceData;
    
    function initialize();

    // SCCP-permissioned.
    function addSynth(ISynth synth) external onlyOwner;
    function removeSynth() external onlyOwner;

    // Returns high precision debt balance of `_issuer`.
    function getDebtBalanceOf(address _issuer) returns (uint) {
        return totalSupply().dividedBy(balanceOf(_issuer)); // TODO: precision
    }
}

contract Exchanger {
}
```

The current issuance of synths happens during the `exchange` function, in a subcall to `_convert`. UI's such as Kwenta use `exchangeWithTracking`. 

All synths are currently issued via the global debt pool. 
The synths can thereby be traded into other synths using the exchange contract. During this call to `exchange`, which internally calls `_convert`, the issuance debt does not change. 


What would we need to change?

Issuance is called through the base Synthetix contract, `Synthetix.issueSynths`
The base contract could be changed to incorporate eSNX.



Remixing these features:
- eSNX
- replacing global debt register with siloed register
- eSNX per pool or 

### Test Cases
<!--Test cases for an implementation are mandatory for SIPs but can be included with the implementation..-->

### Configurable Values (Via SCCP)
<!--Please list all values configurable via SCCP under this implementation.-->

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).



How does the Synthetix protocol work? 

Exchanger
```cpp
    function exchange(
        address from,
        bytes32 sourceCurrencyKey,
        uint sourceAmount,
        bytes32 destinationCurrencyKey,
        address destinationAddress
    ) external onlySynthetixorSynth returns (uint amountReceived) {
        uint fee;
        (amountReceived, fee, ) = _exchange(
            from,
            sourceCurrencyKey,
            sourceAmount,
            destinationCurrencyKey,
            destinationAddress,
            false
        );

        _processTradingRewards(fee, destinationAddress);
    }


    function _exchange(
        address from,
        bytes32 sourceCurrencyKey,
        uint sourceAmount,
        bytes32 destinationCurrencyKey,
        address destinationAddress,
        bool virtualSynth
    )
        internal
        returns (
            uint amountReceived,
            uint fee,
            IVirtualSynth vSynth
        )
    {
        _ensureCanExchange(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);

        uint sourceAmountAfterSettlement = _settleAndCalcSourceAmountRemaining(sourceAmount, from, sourceCurrencyKey);

        // If, after settlement the user has no balance left (highly unlikely), then return to prevent
        // emitting events of 0 and don't revert so as to ensure the settlement queue is emptied
        if (sourceAmountAfterSettlement == 0) {
            return (0, 0, IVirtualSynth(0));
        }

        uint exchangeFeeRate;
        uint sourceRate;
        uint destinationRate;

        // Note: `fee` is denominated in the destinationCurrencyKey.
        (amountReceived, fee, exchangeFeeRate, sourceRate, destinationRate) = _getAmountsForExchangeMinusFees(
            sourceAmountAfterSettlement,
            sourceCurrencyKey,
            destinationCurrencyKey
        );

        // SIP-65: Decentralized Circuit Breaker
        if (
            _suspendIfRateInvalid(sourceCurrencyKey, sourceRate) ||
            _suspendIfRateInvalid(destinationCurrencyKey, destinationRate)
        ) {
            return (0, 0, IVirtualSynth(0));
        }

        // Note: We don't need to check their balance as the burn() below will do a safe subtraction which requires
        // the subtraction to not overflow, which would happen if their balance is not sufficient.

        vSynth = _convert(
            sourceCurrencyKey,
            from,
            sourceAmountAfterSettlement,
            destinationCurrencyKey,
            amountReceived,
            destinationAddress,
            virtualSynth
        );

        // When using a virtual synth, it becomes the destinationAddress for event and settlement tracking
        if (vSynth != IVirtualSynth(0)) {
            destinationAddress = address(vSynth);
        }

        // Remit the fee if required
        if (fee > 0) {
            // Normalize fee to sUSD
            // Note: `fee` is being reused to avoid stack too deep errors.
            fee = exchangeRates().effectiveValue(destinationCurrencyKey, fee, sUSD);

            // Remit the fee in sUSDs
            issuer().synths(sUSD).issue(feePool().FEE_ADDRESS(), fee);

            // Tell the fee pool about this
            feePool().recordFeePaid(fee);
        }

        // Note: As of this point, `fee` is denominated in sUSD.

        // Nothing changes as far as issuance data goes because the total value in the system hasn't changed.
        // But we will update the debt snapshot in case exchange rates have fluctuated since the last exchange
        // in these currencies
        _updateSNXIssuedDebtOnExchange([sourceCurrencyKey, destinationCurrencyKey], [sourceRate, destinationRate]);

        // Let the DApps know there was a Synth exchange
        ISynthetixInternal(address(synthetix())).emitSynthExchange(
            from,
            sourceCurrencyKey,
            sourceAmountAfterSettlement,
            destinationCurrencyKey,
            amountReceived,
            destinationAddress
        );

        // iff the waiting period is gt 0
        if (getWaitingPeriodSecs() > 0) {
            // persist the exchange information for the dest key
            appendExchange(
                destinationAddress,
                sourceCurrencyKey,
                sourceAmountAfterSettlement,
                destinationCurrencyKey,
                amountReceived,
                exchangeFeeRate
            );
        }
    }


    function _updateSNXIssuedDebtOnExchange(bytes32[2] memory currencyKeys, uint[2] memory currencyRates) internal {
        bool includesSUSD = currencyKeys[0] == sUSD || currencyKeys[1] == sUSD;
        uint numKeys = includesSUSD ? 2 : 3;

        bytes32[] memory keys = new bytes32[](numKeys);
        keys[0] = currencyKeys[0];
        keys[1] = currencyKeys[1];

        uint[] memory rates = new uint[](numKeys);
        rates[0] = currencyRates[0];
        rates[1] = currencyRates[1];

        if (!includesSUSD) {
            keys[2] = sUSD; // And we'll also update sUSD to account for any fees if it wasn't one of the exchanged currencies
            rates[2] = SafeDecimalMath.unit();
        }

        // Note that exchanges can't invalidate the debt cache, since if a rate is invalid,
        // the exchange will have failed already.
        // Huh, does that mean exchanges fail after an oracle update, until the debt cache is updated? 
        debtCache().updateCachedSynthDebtsWithRates(keys, rates);
    }
```

Exchanger.exchange
    burns one synth
    issues another
    issues fee to fee pool


To change:

 * Exchanger
   * Fee should be remitted to appropriate fee pool.
   * Or fee could be claimable based on staked SNX (eSNX)?
   * Mint/burn checks should be per-debt pool
   * `_updateSNXIssuedDebtOnExchange` should update each debt pool.
 * Issuer
   * Debt register - `_addToDebtRegister`.
 * FeePool
 * Debt Pool


FeePool maintains the same address.
Fees are claimable proportionate to the % of total eSNX supply.

User <-> (SNX, eSNX) <-> debt pools








Debt Register:
    Measures the changes in the multiplicative changes
        from issuing debt
        from burning debt
    
    Tracks each user's debt as a portion of total debt.

Debt Cache:
    Tracks each synthetic asset's USD-denominated supply.


